# -*- coding: utf-8 -*-
"""
adjusted from Lennart Regebro's tzlocal package for Python.

source: https://github.com/regebro/tzlocal/blob/master/update_windows_mappings.py
"""
import ftplib
import logging
import tarfile

from datetime import datetime
from io import BytesIO
from pathlib import Path
from urllib.parse import urlparse
from urllib.request import urlopen
from xml.dom import minidom

WIN_ZONES_URL = 'https://raw.githubusercontent.com/unicode-org/cldr/master/common/supplemental/windowsZones.xml'
ZONEINFO_URL = 'ftp://ftp.iana.org/tz/tzdata-latest.tar.gz'

logging.basicConfig(level=logging.INFO)
log = logging.getLogger()


def update_old_names():
    """Fetches the list of old tz names and returns a mapping"""
    url = urlparse(ZONEINFO_URL)
    log.info('Connecting to %s' % url.netloc)
    ftp = ftplib.FTP(url.netloc)
    ftp.login()
    gzfile = BytesIO()

    log.info('Fetching zoneinfo database')
    ftp.retrbinary('RETR ' + url.path, gzfile.write)
    gzfile.seek(0)

    log.info('Extracting backwards data')
    archive = tarfile.open(mode="r:gz", fileobj=gzfile)
    backward = {}
    for line in archive.extractfile('backward').readlines():
        if line[0] == '#':
            continue
        if len(line.strip()) == 0:
            continue
        parts = line.split()
        if parts[0] != b'Link':
            continue

        backward[parts[2].decode('ascii')] = parts[1].decode('ascii')

    return backward


def update_windows_zones():
    backward = update_old_names()

    log.info('Fetching Windows mapping info from unicode.org')
    source = urlopen(WIN_ZONES_URL).read()
    dom = minidom.parseString(source)

    for element in dom.getElementsByTagName('mapTimezones'):
        if element.getAttribute('type') == 'windows':
            break

    log.info('Making windows mapping')
    win_tz = {}
    tz_win = {}
    for mapping in element.getElementsByTagName('mapZone'):
        if mapping.getAttribute('territory') == '001':
            win_tz[mapping.getAttribute('other')] = mapping.getAttribute('type').split(' ')[0]
            if win_tz[mapping.getAttribute('other')].startswith('Etc'):
                print (win_tz[mapping.getAttribute('other')], mapping.getAttribute('type').split(' ')[0])

        for tz_name in mapping.getAttribute('type').split(' '):
            tz_win[tz_name] = mapping.getAttribute('other')

    log.info('Adding backwards data')
    # Map in the backwards compatible zone names
    for backward_compat_name, standard_name in backward.items():
        win_zone = tz_win.get(standard_name, None)
        if win_zone:
            tz_win[backward_compat_name] = win_zone

    # Etc/UTC is a common but non-standard alias for Etc/GMT:
    tz_win['Etc/UTC'] = 'UTC'

    log.info('Writing mapping')

    with open(Path('../tzmappings.go'), "wt") as out:
        out.write("package tzlocal\n\n")
        out.write("// A lookup table, mapping Windows time zone names to IANA time zone names"
                  " and vice versa.\n\n"
                  "// This file is autogenerated by the util/update_tzmappings.py script\n"
                  f"// Do not edit.\n// Last created {datetime.utcnow().isoformat(timespec='seconds')}Z\n\n")

        out.write("// WinTZtoIANA maps time zone names used by Windows to those used by IANA\n"
                  "var WinTZtoIANA = map[string]string{\n")

        for k in sorted(win_tz):
            out.write(f'\t"{k}": "{win_tz[k]}",\n')
        out.write("}\n")

        out.write("// IANAtoWinTZ maps time zone names used by IANA to those used by Windows\n"
                  "var IANAtoWinTZ = map[string]string{\n")

        for k in sorted(tz_win):
            out.write(f'\t"{k}":    "{tz_win[k]}",\n')
        out.write("}\n")


    log.info('Done')


if __name__ == '__main__':
    update_windows_zones()